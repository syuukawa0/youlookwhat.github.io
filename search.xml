<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[收集“新奇的网站”]]></title>
      <url>%2F2016%2F11%2F23%2F%E6%94%B6%E9%9B%86%E2%80%9C%E6%96%B0%E5%A5%87%E7%9A%84%E7%BD%91%E7%AB%99%E2%80%9D%2F</url>
      <content type="text"><![CDATA[产品原型制作 Sketch，最佳原型制作工具 Dribbble，养成一双发现并懂得美的眼睛(美图) 新奇-Get quickly inspiration!（页面） 免费的高清图片 UI设计师推荐 站酷(ZCOOL)-设计师互动平台 黄蜂网 UI中国-专业界面交互平台 behance 展示和发现创意作品 颜色搭配及icon制作 ColorHunt-色彩搭配 icon在线制作 icon图标库 RGB颜色值转换成十六进制颜色码 移动应用分发 Fir.im 豌豆荚 play store]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可能是讲解Android事件分发最好的文章]]></title>
      <url>%2F2016%2F11%2F22%2F%E5%8F%AF%E8%83%BD%E6%98%AF%E8%AE%B2%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[这是在简书上看到的一篇文章，感觉非常好，就转了过来，这是老外写的，这个作者翻译过来的。 综合之前在CSDN写过的一篇类似的文章[Android 简述事件分发机制]，差不多这个知识点就清晰了。 我几乎看过国内讲解Android事件分发的所有文章，但遗憾的是都没有这篇讲的好，原因有二：它阐明了具体的事件分发机制的设计意图，让人既知其然，又知其所以然；它没有贴源码，吓唬本宝宝。所以我决定将它翻译出来，造福广大Android开发者。原文请点击这里 有时，你必须要自己处理触摸事件（touch events）而不能依赖于有可用的onSomethingListener。我就遇到过这样的时候，当时我很想有一篇文章能简单地解释触摸事件是怎样在视图层次（view hierarchy）中传播的，从而可以将之作为进一步深入学习的起点。这篇博客是我的一次尝试，它看起来有点长，但这是因为我是按照触摸事件的传播过程一步一步来写的。 一些假设我们只考虑最重要的四个触摸事件，即：DOWN,MOVE,UP和CANCEL。一个手势（gesture）是一个事件列，以一个DOWN事件开始（当用户触摸屏幕时产生），后跟0个或多个MOVE事件（当用户四处移动手指时产生），最后跟一个单独的UP或CANCEL事件（当用户手指离开屏幕或者系统告诉你手势（gesture）由于其他原因结束时产生）。当我们说到“手势剩余部分”时指的是手势后续的MOVE事件和最后的UP或CANCEL事件。 在这里我也不考虑多点触摸手势（我们只假设用一个手指）并且忽略多个MOVE事件可以被归为一组这一实际情况。最后，我们假设文中的view都没有注册onTouchListener。 我们将要讨论的视图层次是这样的：最外层是一个ViewGroup A，包含一个或多个子view（children），其中一个子view是ViewGroup B，ViewGroupB中又包含一个或多个子view，其中一个子view是 View C,C不是一个ViewGroup。这里我们忽略同层级view之间可能的交叉叠加。 假设用户首先触摸到的屏幕上的点是C上的某个点，该点被标记为触摸点（touch point），DOWN事件就在该点产生。然后用户移动手指并最后离开屏幕，此过程中手指是否离开C的区域无关紧要，关键是手势（gesture）是从哪里开始的。 默认情况假设上面的A,B,C都没有覆写默认的事件传播行为，那么下面就是事件传播的过程： DOWN事件被传到C的onTouchEvent方法中，该方法返回false，表示“我不关心这个手势（gesture）”。 因此，DOWN事件被传到B的onTouchEvent方法中，该方法同样返回false，表示B也不关心这个手势。 同样，因为B不关心这个手势，DOWN事件被传到A的onTouchEvent方法中，该方法也返回false。 由于没有view关心这个手势（gesture），它们将不再会从“手势剩余部分”中接收任何事件。 处理事件现在，让我们假设C实际上是关心这个手势（gesture）的，原因可能是C被设置成可点击的（clickable）或者你覆写了C的onTouchEvent方法。 DOWN事件被传递给C的onTouchEvent方法，该方法可以做任何它想做的事情，最后返回true。 因为C说它正在处理这个手势（gesture），则DOWN事件将不再被传递给B和A的onTouchEvent方法。 因为C说它正在处理这个手势（gesture），所以“手势剩余部分”的事件也将传递给C的onTouchEvent方法，此时该方法返回true或false都无关紧要了，但是为保持一致最好还是返回true。 个人理解：从这里可以看出，各个View的onTouchEvent方法对DOWN事件的处理，代表了该View对以此DOWN开始的整个手势（gesture）的处理意愿，返回true代表愿意处理该gesture，返回false代表不愿意处理该gesture。 onInterceptTouchEvent现在我们将讨论一个新的方法：onInterceptTouchEvent，它只存在于ViewGroup中，普通的View中没有这个方法。在任何一个view的onTouchEvent被调用之前，它的父辈们（ancestors）将先获得拦截这个事件的一次机会，换句话说，它们可以窃取该事件。在刚才的“处理事件”部分中，我们遗漏了这一过程，现在，让我们把它加上： DOWN事件被传给A的onInterceptTouchEvent，该方法返回false，表示它不想拦截。 DOWN又被传递给B的onInterceptTouchEvent，它也不想拦截，因此该方法也返回false。 现在，DOWN事件被传递到C的onTouchEvent方法，该方法返回true，因为它想处理以该事件为首的手势（gesture）。 现在，该手势的下一个事件MOVE到来了。这个MOVE事件再一次被传递给A的onInterceptTouchEvent方法，该方法再一次返回false，B也同样如此。 然后，MOVE事件被传递给C的onTouchEvent，就像在前一部分中一样。 “手势剩余部分”中其他事件的处理过程和上面一样，假如A和B的onInterceptTouchEvent方法继续返回false的话。 这里有两点需要注意： 虽然ViewGroup A和B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件依然会传递给它们的onInterceptTouchEvent方法，这一点与onTouchEvent的行为是不一样的。 假如DOWN事件传给C的onTouchEvent方法时，它返回了false，DOWN事件会继续向上传递给B和A的onTouchEvent，即使它们在onInterceptTouchEvent方法中说它们不想拦截这个DOWN事件，但没办法，没有子View愿意处理该事件。 个人理解：感谢@编程世界的孩子 的提醒，由此可见，DOWN事件的处理实际上经历了一下一上两个过程，下是指A-&gt;B的onInterceptTouchEvent，上是指C-&gt;B-&gt;A的onTouchEvent，当然，任意一步的方法中返回true,都能阻止它继续传播。 拦截事件现在，让我们更进一步，假设B没有拦截DOWN事件，但它拦截了接下来的MOVE事件。原因可能是B是一个scrolling view。当用户仅仅在它的区域内点击（tap）时，被点击到的元素应当能处理该点击事件。但是当用户手指移动了一定的距离后，就不能再视该手势（gesture）为点击了——很明显，用户是想scroll。这就是为什么B要接管该手势（gesture）。 下面是事件被处理的顺序： DOWN事件被依次传到A和B的onInterceptTouchEvent方法中，它们都返回的false，因为它们目前还不想拦截。 DOWN事件传递到C的onTouchEvent方法，返回了true。 在后续到来MOVE事件时，A的onInterceptTouchEvent方法仍然返回false。 B的onInterceptTouchEvent方法收到了该MOVE事件，此时B注意到用户手指移动距离已经超过了一定的threshold（或者称为slop）。因此，B的onInterceptTouchEvent方法决定返回true，从而接管该手势（gesture）后续的处理。 然后，这个MOVE事件将会被系统变成一个CANCEL事件，这个CANCEL事件将会传递给C的onTouchEvent方法。 现在，又来了一个MOVE事件，它被传递给A的onInterceptTouchEvent方法，A还是不关心该事件，因此onInterceptTouchEvent方法继续返回false。 此时，该MOVE事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。事实上，该MOVE以及“手势剩余部分”都将传递给B的onTouchEvent方法（除非A决定拦截“手势剩余部分”）。 C再也不会收到该手势（gesture）产生的任何事件了。 下面的一些小事情可能会令你感到吃惊： 如果一个ViewGroup拦截了最初的DOWN事件，该事件仍然会传递到该ViewGroup的onTouchEvent方法中。 另一方面，如果ViewGroup拦截了一个半路的事件（比如，MOVE），这个事件将会被系统变成一个CANCEL事件，并传递给之前处理该手势（gesture）的子View，而且不会再传递（无论是被拦截的MOVE还是系统生成的CANCEL）给ViewGroup的onTouchEvent方法。只有再到来的事件才会传递到ViewGroup的onTouchEvent方法中。 从此开始，你可以更进一步。比如对mouthful-method （实在不知道该怎么翻译啦！）requestDisallowInterceptTouchEvent,C可以用该方法阻止B窃取事件。如果你想更加疯狂一点，你可以在你自己的ViewGroup中直接覆写dispatchTouchEvent方法，并对传递进来的事件做任何你想做的处理。但这样的话你可能会破坏一些约定，所以应当小心。 文／milter（简书作者)原文链接：http://www.jianshu.com/p/2be492c1df96]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac搭建Hexo博客流程记录，排雷完成]]></title>
      <url>%2F2016%2F11%2F19%2FMac%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%8E%92%E9%9B%B7%E5%AE%8C%E6%88%90%2F</url>
      <content type="text"><![CDATA[经过一天的辛苦作战，总算基础的东西出来了。踩了太多的坑，综合我踩坑的经过，明白到，选好一篇引导文很重要！有些步骤不要先做了，不然后面会把你坑的很惨.. 引很多博客都已经详细讲述了Hexo博客框架的好处和怎么做，下面的推荐文章里会给出链接。但有些过于复杂，让初次配置的人有点雨里雾里；有些又太简单，出了问题就会不知道怎么回事。下面是自己的搭建记录，及所遇问题的解决。 在此感谢小马哥Mark和 wingjay先前分享的教程，有些段落是从你们里搬运过来的，希望博主见谅，如有侵权，请联系我删除。 Ok，现在开始： GitHub Pages在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。 首先你需要拥有一个GitHub账号。 然后进入GitHub Pages，一步步做，完成后就能在浏览器打开http://username.github.io了。 至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。 注意：如果你http://username.github.io首页就要是博客首页的话，建议初次配置选择首页，就是这样。完成后可以把index.html给删了，因为到最后你发现那是没用的，它将会给你造成干扰。 前期准备安装Hexo参考中文文档或英文文档。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。 测试安装状态1234567$ node -v v4.2.4$ npm -v2.14.12$ hexo -v 正式开始确定拥有了Git、Node.js和Hexo后，进行下一步： 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这样Hexo会在该文件夹创建本地博客所需的一切资源。这样本地博客就搭建好了，输入以下命令： 1hexo s --debug // 启动本地hexo 服务器，默认localhost:4000可以访问，可以看到调试信息 这样就开启了一个本地博客服务器，打开浏览器，在地址栏输入localhost:4000，就可以查看本地博客了，hexo默认生成了一片hello world博客。出现问题可以看terminal终端错误信息。按control + c关闭调试。 注意：以上hexo开头的命令，执行目录必须是你创建的博客文件夹目录。使用hexo s 也可以，只是没有了调试信息。 同步Hexo博客到Github现在你已经可以在本机查看你的博客了，但是要想让别人通过网络可以查看你的博客，还需要一步，那就是将你的博客发布到github仓库。在terminal终端，将当前目录切换到你的本地博客目录，执行以下命令： 1npm install hexo-deployer-git --save 安装完成之后，打开本地博客目录的_config.yml文件，编辑其中的deploy节点： 1234deploy: type: git repo: https://github.com/youlookwhat/youlookwhat.github.io.git branch: master 注意：字段前需加空格，hexo有严格的格式规范。 保存配置之后，你可以不着急传到仓库，先刷新本地博客，看是否还是原样，如有问题可以看到terminal终端上的错误信息，然后检查没问题为止。 确认无误之后，在本地博客目录执行以下命令： 123hexo clean // clean本地项目，防止缓存hexo g // 全拼是：hexo generate，可以简写成 hexo g; 根据你编辑的md格式的博客，生成静态网页hexo d // 全拼是：hexo deploy，可以简写成 hexo d; 将本地博客发布到github 然后，在浏览器地址栏输入username.github.io就可以访问你的博客了，别人也可以通过这个地址访问你的博客。如果错误请重复看以前流程，或参考其他文章，也可以联系我. NexT主题配置 Next主题 Hexo主题非常多，可以参考丰富多彩的Hexo主题，本文选Next为主题，NexT主题是一套简约的主题，设置完成之后，就像我的博客现在的样子，里面有详细的配置说明，这里就不重述了。 配置后调试： 123hexo cleanhexo ghexo s --debug 确认无误后上传： 123hexo cleanhexo ghexo d 注意：因为hexo有严格的格式规范，所以建议配置时及时调试页面。 优化环节 域名设置 fork me on github 配置SSH key 给博文添加tag和分类(主题) 手动实现某条博文置顶 域名设置大家可以看：替换自己的域名 ,里面讲述的详细。 注意：在万网买了域名以后直接在里面配置，这里只是参考用的。 其它四条大家可以看：其他遗漏的点 注意：配置后进入调试模式测试一下，这样错了就可以马上更正。 常用命令 cd 到仓库所在文件夹目录下： 1234567hexo init //在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件hexo new “my new blog title” //新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。hexo s --debug // 启动本地hexo 服务器，默认localhost:4000可以访问hexo clean // 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存hexo generate // 可以简写成hexo g 根据markdown文件生成静态文件hexo deploy // 或者简写成hexo d 将本地修改，部署到远端hexo version // 显示hexo版本 推荐文章 Mac搭建Hexo博客及NexT主题配置优化 如何在一天之内搭建以你自己名字为域名又具备cool属性的个人博客 使用GitHub和Hexo搭建免费静态Blog 动动手指，NexT主题与Hexo更搭哦（基础篇） 所遇问题 按照步骤来，及时调试，确认无误后再执行下一步。有一句话说的好，步子跨大了容易扯着蛋。 建议将基础的先搭建出来，主题细节可以之后再慢慢配置。 编辑站点_config.yml文件其中的deploy节点时，注意repo的值。 替换域名时： 直接在万维网设置解析方式； 在仓库Setting的要设置跳转链接； CNAME会被覆盖，安装CNAME工具hexo-generator-cname 为博客文章添加阅读量统计功能，参照这里，注意顺序，我在其中被坑过。 设置网站图标时，就是上传“.ico”文件时，确认成功后浏览器会有缓存，显示不出来，关掉浏览器清除缓存就好了（可放在最后）。 设置代码高亮主题测试时没事，上传后会有延迟，等等就好了（本人这样）。 设置搜索栏，进入swiftype官网，注册不上，应该收费了- -. 设置侧边栏社交链接时，social:下面字段前要有两个空格，切记。 相关网址NexT、多说、百度统计、leancloud、阿里云、fork me、ico制作 联系我 我的简书 我的CSDN 我的个人博客]]></content>
    </entry>

    
  
  
</search>
